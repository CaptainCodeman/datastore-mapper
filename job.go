package mapper

import (
	"bytes"

	"encoding/gob"

	"golang.org/x/net/context"
	"google.golang.org/appengine/datastore"
	"google.golang.org/appengine/log"
)

type (
	// job is the datastore struct to control execution of a job instance
	job struct {
		common
		lock

		// Job is the job processor struct
		Job JobSpec `datastore:"-"`

		// Query provides the source to process
		Query *Query `datastore:"-"`

		// Bucket defines the cloud storage bucket to write output to
		// if empty, then no output will be written
		Bucket string `datastore:"bucket,noindex"`

		// Abort is used to cancel a job
		Abort bool `datastore:"abort,noindex"`

		// Shards is the target number of shards to use when splitting a namespace
		Shards int `datastore:"shards,noindex"`

		// Iterating indicates if the iterator is still active
		Iterating bool `datastore:"iterating,noindex"`

		// NamespacesTotal is the total number of namespaces generated by the iterator
		NamespacesTotal int `datastore:"ns_total,noindex"`

		// NamespacesSuccessful is the number of namespaces completed successfully
		NamespacesSuccessful int `datastore:"ns_successful,noindex"`

		// NamespacesFailed is the number of namespaces failed
		NamespacesFailed int `datastore:"ns_failed,noindex"`
	}
)

const (
	jobKind = "job"
)

func (j *job) start(c context.Context, config Config) error {
	if config.LogVerbose {
		log.Debugf(c, "creating iterator for job %s", j.id)
	}
	iterator := new(iterator)
	iterator.start()

	key := datastore.NewKey(c, config.DatastorePrefix+iteratorKind, j.id, 0, nil)
	return ScheduleLock(c, key, iterator, config.Path+iteratorURL, nil, j.queue)
}

func (j *job) completed(c context.Context, config Config, key *datastore.Key) error {
	j.complete()
	j.RequestID = ""

	// everything is complete when this runs, so no need for a transaction 
	if _, err := storage.Put(c, key, j); err != nil {
		return err
	}

	return nil
}

// Load implements the datastore PropertyLoadSaver imterface
func (j *job) Load(props []datastore.Property) error {
	datastore.LoadStruct(j, props)

	for _, prop := range props {
		switch prop.Name {
		case "job":
			payload := bytes.NewBuffer(prop.Value.([]byte))
			enc := gob.NewDecoder(payload)
			if err := enc.Decode(&j.Job); err != nil {
				return err
			}
		case "query":
			j.Query = &Query{}
			if err := j.Query.GobDecode(prop.Value.([]byte)); err != nil {
				return err
			}
		}
	}

	j.common.Load(props)
	j.lock.Load(props)

	return nil
}

// Save implements the datastore PropertyLoadSaver imterface
func (j *job) Save() ([]datastore.Property, error) {
	props, err := datastore.SaveStruct(j)
	if err != nil {
		return nil, err
	}

	payload := new(bytes.Buffer)
	enc := gob.NewEncoder(payload)
	if err := enc.Encode(&j.Job); err != nil {
		return nil, err
	}
	props = append(props, datastore.Property{Name: "job", Value: payload.Bytes(), NoIndex: true, Multiple: false})

	b, err := j.Query.GobEncode()
	if err != nil {
		return nil, err
	}
	props = append(props, datastore.Property{Name: "query", Value: b, NoIndex: true, Multiple: false})

	jprops, err := j.common.Save()
	if err != nil {
		return nil, err
	}
	props = append(props, jprops...)

	lprops, err := j.lock.Save()
	if err != nil {
		return nil, err
	}
	props = append(props, lprops...)

	return props, nil
}
